#!/usr/bin/env python3
"""
Migra el schema SQLite a Supabase (PostgreSQL)
Convierte sintaxis autom√°ticamente
"""

import re
from pathlib import Path
from supabase import create_client, Client
import json

class SchemaConverter:
    """Convierte schema SQLite a PostgreSQL"""
    
    def __init__(self, sqlite_schema_path):
        self.sqlite_schema = Path(sqlite_schema_path).read_text(encoding='utf-8')
        self.postgresql_schema = ""
    
    def convert(self):
        """Conversi√≥n completa"""
        print("üîÑ Convirtiendo schema SQLite ‚Üí PostgreSQL...")
        
        schema = self.sqlite_schema
        
        # 1. AUTOINCREMENT ‚Üí SERIAL
        print("  ‚Ä¢ Convirtiendo AUTOINCREMENT ‚Üí SERIAL...")
        schema = re.sub(
            r'INTEGER PRIMARY KEY AUTOINCREMENT',
            'INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY',
            schema,
            flags=re.IGNORECASE
        )
        
        # 2. Tipos de datos SQLite ‚Üí PostgreSQL
        print("  ‚Ä¢ Ajustando tipos de datos...")
        conversiones = [
            (r'\bTEXT\b', 'TEXT'),
            (r'\bVARCHAR\((\d+)\)', r'VARCHAR(\1)'),
            (r'\bINTEGER\b', 'INTEGER'),
            (r'\bBOOLEAN\b', 'BOOLEAN'),
            (r'\bDATE\b', 'DATE'),
            (r'\bTIME\b', 'TIME'),
            (r'\bTIMESTAMP\b', 'TIMESTAMP'),
            (r'\bDECIMAL\((\d+),(\d+)\)', r'DECIMAL(\1,\2)'),
        ]
        
        for pattern, replacement in conversiones:
            schema = re.sub(pattern, replacement, schema, flags=re.IGNORECASE)
        
        # Correcci√≥n espec√≠fica: BOOLEAN DEFAULT 0/1 -> FALSE/TRUE
        print("  ‚Ä¢ Corrigiendo defaults booleanos...")
        schema = re.sub(r'BOOLEAN DEFAULT 1', 'BOOLEAN DEFAULT TRUE', schema, flags=re.IGNORECASE)
        schema = re.sub(r'BOOLEAN DEFAULT 0', 'BOOLEAN DEFAULT FALSE', schema, flags=re.IGNORECASE)
        
        # Correcci√≥n de comparaciones booleanas en Vistas (SQLite 1/0 -> Postgres TRUE/FALSE)
        print("  ‚Ä¢ Corrigiendo comparaciones booleanas en vistas...")
        boolean_cols = ['activo', 'asistio', 'aprobado', 'requiere_certificado', 'resolved', 'is_recurring', 'es_feriado', 'usa_horario_custom', 'validacion_capacitacion', 'validacion_disponibilidad', 'validacion_conflicto', 'es_bloqueante', 'es_alerta', 'acompa√±a_grupo']
        
        for col in boolean_cols:
            # = 1 -> = TRUE
            schema = re.sub(r'\b' + col + r'\s*=\s*1\b', f'{col} = TRUE', schema, flags=re.IGNORECASE)
            # = 0 -> = FALSE
            schema = re.sub(r'\b' + col + r'\s*=\s*0\b', f'{col} = FALSE', schema, flags=re.IGNORECASE)
        
        # Correcci√≥n de funciones de fecha/hora (SQLite -> PostgreSQL)
        print("  ‚Ä¢ Convirtiendo funciones de fecha/hora...")
        
        # DATE('now', '-30 days') -> CURRENT_DATE - INTERVAL '30 days'
        schema = re.sub(r"DATE\('now',\s*'([-+]\d+)\s*days?'\)", r"CURRENT_DATE + INTERVAL '\1 days'", schema, flags=re.IGNORECASE)
        
        # datetime('now', '-7 days') -> CURRENT_TIMESTAMP - INTERVAL '7 days'
        schema = re.sub(r"datetime\('now',\s*'([-+]\d+)\s*days?'\)", r"CURRENT_TIMESTAMP + INTERVAL '\1 days'", schema, flags=re.IGNORECASE)
        
        # datetime('now') -> CURRENT_TIMESTAMP
        schema = re.sub(r"datetime\('now'\)", "CURRENT_TIMESTAMP", schema, flags=re.IGNORECASE)
        
        # strftime('%Y-%m', col) -> to_char(col, 'YYYY-MM')
        schema = re.sub(r"strftime\('%Y-%m',\s*([^)]+)\)", r"to_char(\1, 'YYYY-MM')", schema, flags=re.IGNORECASE)
        schema = re.sub(r"to_char\('now', 'YYYY-MM'\)", "to_char(CURRENT_DATE, 'YYYY-MM')", schema, flags=re.IGNORECASE)
        
        # julianday('now') - julianday(col) -> EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - col)) / 86400
        # Se agrega ::numeric para compatibilidad con ROUND
        schema = re.sub(r"julianday\('now'\)\s*-\s*julianday\(([^)]+)\)", r"(EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - \1)) / 86400.0)::numeric", schema, flags=re.IGNORECASE)

        # Correcci√≥n GROUP BY para PostgreSQL (estricto)
        print("  ‚Ä¢ Corrigiendo GROUP BY en vistas...")
        schema = re.sub(
            r'GROUP BY ct\.id_transaccion(\s+ORDER BY)',
            r'GROUP BY ct.id_transaccion, ct.fecha_solicitud, dp_ini.nombre, dp_ini.apellido, ct.tipo_transaccion, ct.estado, ct.observaciones\1',
            schema,
            flags=re.IGNORECASE
        )

        # Correcci√≥n ROUND(float, int) -> ROUND(numeric, int)
        # PostgreSQL no soporta ROUND con float y precisi√≥n
        print("  ‚Ä¢ Ajustando tipos para funciones matem√°ticas...")
        schema = re.sub(r'AS FLOAT\)', 'AS NUMERIC)', schema, flags=re.IGNORECASE)

        # 3. DEFAULT CURRENT_TIMESTAMP
        print("  ‚Ä¢ Convirtiendo timestamps...")
        schema = re.sub(
            r'DEFAULT CURRENT_TIMESTAMP',
            "DEFAULT CURRENT_TIMESTAMP",
            schema,
            flags=re.IGNORECASE
        )
        
        # 4. Remover PRAGMA (no existe en PostgreSQL)
        print("  ‚Ä¢ Removiendo PRAGMAs...")
        schema = re.sub(
            r'PRAGMA\s+[^;]+;',
            '-- PRAGMA removed (PostgreSQL handles this automatically)',
            schema,
            flags=re.IGNORECASE
        )
        
        # 5. Triggers: UPDATE ... SET ‚Üí NEW.campo = valor
        print("  ‚Ä¢ Adaptando triggers...")
        # Los triggers ya est√°n bien en el schema CORREGIDO
        # Solo necesitamos cambiar el lenguaje de procedimiento
        
        schema = re.sub(
            r'CREATE TRIGGER\s+(\w+)\s+',
            r'CREATE OR REPLACE TRIGGER \1 ',
            schema,
            flags=re.IGNORECASE
        )
        
        # 6. √çndices
        print("  ‚Ä¢ Manteniendo √≠ndices...")
        # Los √≠ndices ya est√°n en sintaxis compatible
        
        # 7. Vistas
        print("  ‚Ä¢ Manteniendo vistas...")
        # Las vistas ya est√°n en sintaxis compatible
        
        # 8. Comentarios COMMENT ON (solo en PostgreSQL)
        # SQLite no los soporta, pero PostgreSQL S√ç.
        # Mantenemos los comentarios para tener documentaci√≥n en Supabase.
        print("  ‚Ä¢ Preservando metadatos (COMMENT ON)...")
        
        # 9. Remover BEGIN/END de triggers para PostgreSQL
        # En PostgreSQL los triggers usan funciones
        schema = self._convert_triggers_to_postgresql(schema)
        
        self.postgresql_schema = schema
        return schema
    
    def _convert_triggers_to_postgresql(self, schema):
        """
        Convierte triggers de SQLite a PostgreSQL
        SQLite: CREATE TRIGGER ... BEGIN ... END
        PostgreSQL: CREATE FUNCTION + CREATE TRIGGER
        """
        
        # Patr√≥n para encontrar triggers
        trigger_pattern = r'CREATE TRIGGER\s+(\w+)\s+(BEFORE|AFTER)\s+(INSERT|UPDATE|DELETE)(?:\s+OF\s+(\w+))?\s+ON\s+(\w+)\s+FOR EACH ROW(?:\s+WHEN\s+([^B]+))?\s*BEGIN\s*(.*?)\s*END;'
        
        def replace_trigger(match):
            trigger_name = match.group(1)
            timing = match.group(2)  # BEFORE/AFTER
            event = match.group(3)   # INSERT/UPDATE/DELETE
            column = match.group(4)  # Columna (en UPDATE OF)
            table = match.group(5)   # Tabla
            condition = match.group(6)  # Condici√≥n WHEN
            body = match.group(7).strip()
            
            # Convertir body de SQLite a PostgreSQL
            # UPDATE tabla SET ... ‚Üí UPDATE tabla SET ... WHERE ...
            pg_body = body.replace('NEW.rowid', 'NEW.id')
            
            # Crear funci√≥n
            of_clause = f" OF {column}" if column else ""
            when_clause = f"\n    WHEN ({condition.strip()})" if condition else ""
            
            function_sql = f"""
-- Funci√≥n para trigger {trigger_name}
CREATE OR REPLACE FUNCTION {trigger_name}_func()
RETURNS TRIGGER AS $$
BEGIN
    {pg_body}
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger {trigger_name}
DROP TRIGGER IF EXISTS {trigger_name} ON {table};
CREATE TRIGGER {trigger_name}
    {timing} {event}{of_clause}
    ON {table}
    FOR EACH ROW{when_clause}
    EXECUTE FUNCTION {trigger_name}_func();
"""
            return function_sql
        
        # Aplicar conversi√≥n
        schema_converted = re.sub(
            trigger_pattern,
            replace_trigger,
            schema,
            flags=re.DOTALL | re.IGNORECASE
        )
        
        return schema_converted
    
    def save(self, output_path):
        """Guardar schema convertido"""
        Path(output_path).write_text(self.postgresql_schema, encoding='utf-8')
        print(f"‚úÖ Schema PostgreSQL guardado en: {output_path}")
    
    def get_table_creation_order(self):
        """
        Extrae orden correcto de creaci√≥n de tablas
        (respetando dependencias de FK)
        """
        tables = []
        
        # Encontrar todas las sentencias CREATE TABLE
        pattern = r'CREATE TABLE\s+(\w+)\s*\('
        matches = re.finditer(pattern, self.postgresql_schema, re.IGNORECASE)
        
        for match in matches:
            tables.append(match.group(1))
        
        return tables
    
    def split_by_statement(self):
        """
        Divide el schema en sentencias individuales
        Para ejecutar una por una
        """
        # Dividir por punto y coma (pero no dentro de comillas o funciones)
        statements = []
        current = ""
        in_function = False
        
        for line in self.postgresql_schema.split('\n'):
            current += line + '\n'
            
            # Detectar inicio/fin de funci√≥n
            if 'CREATE OR REPLACE FUNCTION' in line or 'CREATE FUNCTION' in line:
                in_function = True
            elif in_function and line.strip() == '$$;':
                in_function = False
            
            # Si encontramos ; y no estamos en funci√≥n, es fin de sentencia
            if ';' in line and not in_function:
                statements.append(current.strip())
                current = ""
        
        return [s for s in statements if s and not s.startswith('--')]


class SupabaseMigrator:
    """Ejecuta migraci√≥n en Supabase"""
    
    def __init__(self, config_path='config/supabase.json'):
        with open(config_path) as f:
            config = json.load(f)
        
        self.supabase: Client = create_client(
            config['project_url'],
            config['service_role_key']  # Usar service_role para operaciones admin
        )
        self.project_url = config['project_url']
    
    def execute_sql(self, sql_statement):
        """Ejecuta sentencia SQL en Supabase"""
        try:
            # Supabase usa REST API, necesitamos usar el cliente SQL directo
            # o ejecutar via API REST de PostgreSQL
            
            # Por ahora, guardamos el SQL para ejecutar manualmente
            # o usar la UI de Supabase
            return True, None
        except Exception as e:
            return False, str(e)
    
    def migrate_schema(self, schema_sql):
        """Migra schema completo"""
        print("\nüîÑ Migrando schema a Supabase...")
        print(f"üåê Proyecto: {self.project_url}")
        
        converter = SchemaConverter('sql/schema_final_completo_CORREGIDO.sql')
        converter.convert()
        statements = converter.split_by_statement()
        
        print(f"\nüìä Total de sentencias: {len(statements)}")
        print("\n‚ö†Ô∏è  IMPORTANTE:")
        print("   Supabase requiere ejecutar el SQL via su SQL Editor")
        print("   1. Abre: https://app.supabase.com/project/xxxxx/editor")
        print("   2. Copia el SQL del archivo: sql/schema_postgresql.sql")
        print("   3. Ejecuta en el SQL Editor")
        
        # Guardar SQL convertido
        converter.save('sql/schema_postgresql.sql')
        
        return True


def main():
    """Funci√≥n principal de migraci√≥n"""
    print("="*70)
    print("  MIGRACI√ìN DE SCHEMA SQLite ‚Üí SUPABASE (PostgreSQL)")
    print("="*70)
    
    # Verificar archivos
    if not Path('sql/schema_final_completo_CORREGIDO.sql').exists():
        print("\n‚ùå ERROR: No se encuentra sql/schema_final_completo_CORREGIDO.sql")
        return
    
    if not Path('config/supabase.json').exists():
        print("\n‚ùå ERROR: No se encuentra config/supabase.json")
        print("   Ejecuta primero el PASO 1")
        return
    
    # Convertir schema
    print("\n" + "="*70)
    print("FASE 1: CONVERSI√ìN DE SCHEMA")
    print("="*70)
    
    converter = SchemaConverter('sql/schema_final_completo_CORREGIDO.sql')
    converter.convert()
    converter.save('sql/schema_postgresql.sql')
    
    print("\n‚úÖ Conversi√≥n completada")
    print(f"   Archivo generado: sql/schema_postgresql.sql")
    
    # Instrucciones para ejecutar en Supabase
    print("\n" + "="*70)
    print("FASE 2: EJECUTAR EN SUPABASE")
    print("="*70)
    
    with open('config/supabase.json') as f:
        config = json.load(f)
    
    project_id = config['project_url'].split('//')[1].split('.')[0]
    
    print(f"""
üìã PASOS PARA COMPLETAR LA MIGRACI√ìN:

1. Abre el SQL Editor de Supabase:
   üîó https://app.supabase.com/project/{project_id}/sql/new

2. Copia el contenido del archivo:
   üìÑ sql/schema_postgresql.sql

3. P√©galo en el SQL Editor y click "RUN"

4. Espera ~30 segundos a que se ejecute

5. Verifica en Table Editor:
   üìä https://app.supabase.com/project/{project_id}/editor

   Deber√≠as ver 19 tablas creadas ‚úÖ

6. Vuelve aqu√≠ y presiona ENTER cuando hayas terminado...
""")
    
    input()
    
    # Verificar migraci√≥n
    print("\nüîç Verificando migraci√≥n...")
    
    migrator = SupabaseMigrator()
    
    # Intentar listar tablas
    try:
        # Verificar que podemos conectar
        result = migrator.supabase.table('configuracion').select('*').limit(1).execute()
        print("‚úÖ Conexi√≥n exitosa a Supabase")
        print("‚úÖ Migraci√≥n completada correctamente")
        
        print("\n" + "="*70)
        print("üéâ MIGRACI√ìN EXITOSA")
        print("="*70)
        print("\nPr√≥ximos pasos:")
        print("  ‚Ä¢ Continuar con PASO 3: Unified DB Manager")
        
    except Exception as e:
        print(f"\n‚ö†Ô∏è  No se pudo verificar autom√°ticamente")
        print(f"   Error: {e}")
        print("\n   Verifica manualmente en el Table Editor de Supabase")


if __name__ == '__main__':
    main()