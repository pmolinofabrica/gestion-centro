-- ============================================================================
-- SISTEMA DE GESTI√ìN DE RECURSOS HUMANOS - VERSION FINAL 2.0
-- Base de datos: SQLite (preparada para PostgreSQL)
-- Contexto: Centro Cultural con rotaci√≥n anual 100%
-- Enfoque: Python + SQL Avanzado para Data Analyst
-- Autor: Pablo - Data Analyst
-- Fecha: Diciembre 2025
-- ============================================================================
-- 
-- COMPLETITUD: 98%
-- - 19 tablas (incluye capacitaciones_participantes)
-- - 13 triggers autom√°ticos
-- - 11 vistas anal√≠ticas
-- - Sistema de logging completo
-- - Validaciones robustas
-- ============================================================================

-- PRAGMA removed (PostgreSQL handles this automatically)

-- ============================================================================
-- M√ìDULO 1: TABLAS MAESTRAS (Cat√°logos)
-- ============================================================================

CREATE TABLE dispositivos (
    id_dispositivo INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    nombre_dispositivo VARCHAR(100) NOT NULL,
    piso_dispositivo INTEGER NOT NULL,
    activo BOOLEAN DEFAULT TRUE,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_piso CHECK (piso_dispositivo >= 0)
);

CREATE INDEX idx_dispositivos_piso ON dispositivos(piso_dispositivo);
CREATE INDEX idx_dispositivos_activo ON dispositivos(activo);

-- ----------------------------------------------------------------------------

CREATE TABLE dias (
    id_dia INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    fecha DATE NOT NULL UNIQUE,
    mes INTEGER NOT NULL,
    semana INTEGER NOT NULL,
    dia INTEGER NOT NULL,
    numero_dia_semana INTEGER NOT NULL,
    es_feriado BOOLEAN DEFAULT FALSE,
    nombre_feriado VARCHAR(200),
    CONSTRAINT chk_mes CHECK (mes BETWEEN 1 AND 12),
    CONSTRAINT chk_dia CHECK (dia BETWEEN 1 AND 31),
    CONSTRAINT chk_numero_dia CHECK (numero_dia_semana BETWEEN 0 AND 8)
);

CREATE UNIQUE INDEX idx_dias_fecha ON dias(fecha);
CREATE INDEX idx_dias_mes ON dias(mes);
CREATE INDEX idx_dias_numero_dia_semana ON dias(numero_dia_semana);

-- ----------------------------------------------------------------------------

CREATE TABLE turnos (
    id_turno INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    numero_dia_semana INTEGER NOT NULL,
    tipo_turno VARCHAR(50) NOT NULL,
    hora_inicio TIME NOT NULL,
    hora_fin TIME NOT NULL,
    cant_horas DECIMAL(4,2) NOT NULL,
    turno_notas TEXT,
    activo BOOLEAN DEFAULT TRUE,
    CONSTRAINT chk_tipo_turno CHECK (tipo_turno IN ('ma√±ana', 'tarde', 'capacitacion', 'apertura_publico', 'descanso', 'intermedio', 'apertura_publico_corto', 'apertura_publico_largo')),
    CONSTRAINT chk_numero_dia_turno CHECK (numero_dia_semana BETWEEN 0 AND 8),
    CONSTRAINT chk_horas CHECK (cant_horas >= 0 AND cant_horas <= 24)
);

CREATE INDEX idx_turnos_numero_dia ON turnos(numero_dia_semana);
CREATE INDEX idx_turnos_tipo ON turnos(tipo_turno);

-- ----------------------------------------------------------------------------

CREATE TABLE datos_personales (
    id_agente INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    dni VARCHAR(20) NOT NULL UNIQUE,
    fecha_nacimiento DATE NOT NULL,
    email VARCHAR(150) NOT NULL,
    telefono VARCHAR(20),
    domicilio TEXT,
    activo BOOLEAN DEFAULT TRUE,
    fecha_alta TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_baja TIMESTAMP,
    CONSTRAINT chk_email CHECK (email LIKE '%@%')
);

CREATE UNIQUE INDEX idx_agentes_dni ON datos_personales(dni);
CREATE INDEX idx_agentes_activo ON datos_personales(activo);
CREATE INDEX idx_agentes_nombre_apellido ON datos_personales(apellido, nombre);

-- ----------------------------------------------------------------------------

CREATE TABLE planificacion (
    id_plani INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_dia INTEGER NOT NULL,
    id_turno INTEGER NOT NULL,
    cant_residentes_plan INTEGER NOT NULL,
    cant_visit INTEGER DEFAULT 0,
    plani_notas TEXT,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_plani_dia FOREIGN KEY (id_dia) REFERENCES dias(id_dia),
    CONSTRAINT fk_plani_turno FOREIGN KEY (id_turno) REFERENCES turnos(id_turno),
    CONSTRAINT chk_cant_residentes CHECK (cant_residentes_plan > 0),
    CONSTRAINT chk_cant_visit CHECK (cant_visit >= 0),
    CONSTRAINT uq_plani_dia_turno UNIQUE (id_dia, id_turno)
);

CREATE INDEX idx_plani_dia ON planificacion(id_dia);
CREATE INDEX idx_plani_turno ON planificacion(id_turno);

-- ============================================================================
-- M√ìDULO 2: CAPACITACIONES
-- ============================================================================

CREATE TABLE capacitaciones (
    id_cap INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_dia INTEGER NOT NULL,
    coordinador_cap INTEGER NOT NULL,
    tema VARCHAR(200) NOT NULL,
    grupo VARCHAR(50),
    observaciones TEXT,
    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_cap_dia FOREIGN KEY (id_dia) REFERENCES dias(id_dia),
    CONSTRAINT fk_cap_coordinador FOREIGN KEY (coordinador_cap) 
        REFERENCES datos_personales(id_agente) ON DELETE RESTRICT
);

CREATE INDEX idx_cap_dia ON capacitaciones(id_dia);
CREATE INDEX idx_cap_coordinador ON capacitaciones(coordinador_cap);

-- ----------------------------------------------------------------------------

CREATE TABLE capacitaciones_dispositivos (
    id_cap_dispo INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_cap INTEGER NOT NULL,
    id_dispositivo INTEGER NOT NULL,
    orden INTEGER DEFAULT 1,
    CONSTRAINT fk_cap_dispo_cap FOREIGN KEY (id_cap) 
        REFERENCES capacitaciones(id_cap) ON DELETE CASCADE,
    CONSTRAINT fk_cap_dispo_dispo FOREIGN KEY (id_dispositivo) 
        REFERENCES dispositivos(id_dispositivo) ON DELETE RESTRICT,
    CONSTRAINT uq_cap_dispositivo UNIQUE (id_cap, id_dispositivo)
);

CREATE INDEX idx_cap_dispo_cap ON capacitaciones_dispositivos(id_cap);
CREATE INDEX idx_cap_dispo_dispositivo ON capacitaciones_dispositivos(id_dispositivo);

-- ----------------------------------------------------------------------------
-- NUEVA TABLA: Participantes de capacitaciones
-- ----------------------------------------------------------------------------

CREATE TABLE capacitaciones_participantes (
    id_participante INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_cap INTEGER NOT NULL,
    id_agente INTEGER NOT NULL,
    fecha_inscripcion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    asistio BOOLEAN DEFAULT FALSE,
    aprobado BOOLEAN,
    calificacion DECIMAL(4,2),
    observaciones TEXT,
    fecha_certificado TIMESTAMP,
    
    CONSTRAINT fk_cap_part_cap FOREIGN KEY (id_cap) 
        REFERENCES capacitaciones(id_cap) ON DELETE CASCADE,
    CONSTRAINT fk_cap_part_agente FOREIGN KEY (id_agente) 
        REFERENCES datos_personales(id_agente) ON DELETE CASCADE,
    CONSTRAINT uq_cap_agente UNIQUE (id_cap, id_agente),
    CONSTRAINT chk_calificacion CHECK (calificacion IS NULL OR (calificacion BETWEEN 0 AND 10))
);

CREATE INDEX idx_cap_part_cap ON capacitaciones_participantes(id_cap);
CREATE INDEX idx_cap_part_agente ON capacitaciones_participantes(id_agente);
CREATE INDEX idx_cap_part_asistio ON capacitaciones_participantes(asistio);
CREATE INDEX idx_cap_part_aprobado ON capacitaciones_participantes(aprobado);

-- ============================================================================
-- M√ìDULO 3: CONVOCATORIAS (Versi√≥n Mejorada - Inmutable)
-- ============================================================================

CREATE TABLE convocatoria (
    id_convocatoria INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_plani INTEGER NOT NULL,
    id_agente INTEGER NOT NULL,
    id_turno INTEGER NOT NULL,
    fecha_convocatoria DATE NOT NULL,
    
    estado VARCHAR(20) DEFAULT 'vigente',
    -- 'vigente', 'historica', 'cancelada', 'cumplida', 'con_inasistencia'
    
    id_convocatoria_origen INTEGER,
    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_modificacion TIMESTAMP,
    motivo_cambio TEXT,
    usuario_modificacion VARCHAR(100),
    
    CONSTRAINT fk_conv_plani FOREIGN KEY (id_plani) REFERENCES planificacion(id_plani),
    CONSTRAINT fk_conv_agente FOREIGN KEY (id_agente) 
        REFERENCES datos_personales(id_agente) ON DELETE RESTRICT,
    CONSTRAINT fk_conv_turno FOREIGN KEY (id_turno) REFERENCES turnos(id_turno),
    CONSTRAINT fk_conv_origen FOREIGN KEY (id_convocatoria_origen) 
        REFERENCES convocatoria(id_convocatoria),
    CONSTRAINT chk_estado_conv CHECK (estado IN ('vigente', 'historica', 'cancelada', 'cumplida', 'con_inasistencia'))
);

CREATE INDEX idx_conv_plani ON convocatoria(id_plani);
CREATE INDEX idx_conv_agente ON convocatoria(id_agente);
CREATE INDEX idx_conv_fecha ON convocatoria(fecha_convocatoria);
CREATE INDEX idx_conv_estado ON convocatoria(estado);
CREATE INDEX idx_conv_agente_fecha_estado ON convocatoria(id_agente, fecha_convocatoria, estado);

-- Trigger: Prevenir m√∫ltiples convocatorias vigentes para mismo agente/fecha
CREATE OR REPLACE FUNCTION func_prevent_duplicate_vigente()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM convocatoria
        WHERE id_agente = NEW.id_agente
        AND fecha_convocatoria = NEW.fecha_convocatoria
        AND estado = 'vigente'
    ) THEN
        RAISE EXCEPTION 'ERROR: El agente ya tiene una convocatoria vigente para esta fecha';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_prevent_duplicate_vigente
BEFORE INSERT ON convocatoria
FOR EACH ROW
WHEN (NEW.estado = 'vigente')
EXECUTE FUNCTION func_prevent_duplicate_vigente();

-- Trigger: Actualizar fecha de modificaci√≥n
CREATE OR REPLACE FUNCTION func_update_fecha_modificacion()
RETURNS TRIGGER AS $$
BEGIN
    NEW.fecha_modificacion := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_fecha_modificacion
BEFORE UPDATE ON convocatoria
FOR EACH ROW
WHEN (OLD.estado IS DISTINCT FROM NEW.estado)
EXECUTE FUNCTION func_update_fecha_modificacion();

-- ----------------------------------------------------------------------------

CREATE TABLE convocatoria_historial (
    id_hist INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_convocatoria INTEGER NOT NULL,
    id_agente_anterior INTEGER NOT NULL,
    id_agente_nuevo INTEGER NOT NULL,
    fecha_cambio TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    tipo_cambio VARCHAR(30) NOT NULL,
    motivo TEXT,
    id_transaccion_cambio INTEGER,
    usuario_responsable VARCHAR(100),
    
    CONSTRAINT fk_hist_conv FOREIGN KEY (id_convocatoria) 
        REFERENCES convocatoria(id_convocatoria),
    CONSTRAINT fk_hist_agente_ant FOREIGN KEY (id_agente_anterior) 
        REFERENCES datos_personales(id_agente),
    CONSTRAINT fk_hist_agente_nue FOREIGN KEY (id_agente_nuevo) 
        REFERENCES datos_personales(id_agente),
    CONSTRAINT chk_tipo_cambio_hist CHECK (tipo_cambio IN ('intercambio', 'reasignacion', 'cancelacion', 'correccion'))
);

CREATE INDEX idx_hist_convocatoria ON convocatoria_historial(id_convocatoria);
CREATE INDEX idx_hist_fecha ON convocatoria_historial(fecha_cambio);

-- Trigger: Registrar en historial cuando cambia agente
CREATE OR REPLACE FUNCTION func_registrar_historial_cambio()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO convocatoria_historial (
        id_convocatoria, id_agente_anterior, id_agente_nuevo,
        tipo_cambio, motivo
    )
    VALUES (
        NEW.id_convocatoria, OLD.id_agente, NEW.id_agente,
        'reasignacion', NEW.motivo_cambio
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_registrar_historial_cambio
AFTER UPDATE ON convocatoria
FOR EACH ROW
WHEN (OLD.id_agente IS DISTINCT FROM NEW.id_agente OR OLD.estado IS DISTINCT FROM NEW.estado)
EXECUTE FUNCTION func_registrar_historial_cambio();

-- ============================================================================
-- M√ìDULO 4: SISTEMA DE CAMBIOS DE TURNO (Modelo Transaccional)
-- ============================================================================

CREATE TABLE cambio_transaccion (
    id_transaccion INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    fecha_solicitud TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    agente_iniciador INTEGER NOT NULL,
    tipo_transaccion VARCHAR(30) NOT NULL,
    estado VARCHAR(20) DEFAULT 'pendiente',
    
    fecha_validacion TIMESTAMP,
    fecha_aprobacion TIMESTAMP,
    fecha_ejecucion TIMESTAMP,
    usuario_aprobador VARCHAR(100),
    motivo_rechazo TEXT,
    observaciones TEXT,
    
    CONSTRAINT fk_cambio_iniciador FOREIGN KEY (agente_iniciador) 
        REFERENCES datos_personales(id_agente),
    CONSTRAINT chk_tipo_transaccion CHECK (tipo_transaccion IN ('intercambio_fechas', 'intercambio_horarios', 'reasignacion_simple')),
    CONSTRAINT chk_estado_transaccion CHECK (estado IN ('pendiente', 'validada', 'aprobada', 'ejecutada', 'rechazada', 'cancelada', 'error'))
);

CREATE INDEX idx_trans_iniciador ON cambio_transaccion(agente_iniciador);
CREATE INDEX idx_trans_estado ON cambio_transaccion(estado);

-- ----------------------------------------------------------------------------

CREATE TABLE cambio_transaccion_detalle (
    id_detalle INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_transaccion INTEGER NOT NULL,
    secuencia INTEGER NOT NULL,
    
    id_convocatoria_original INTEGER NOT NULL,
    id_agente_original INTEGER NOT NULL,
    fecha_original DATE NOT NULL,
    id_turno_original INTEGER NOT NULL,
    
    id_convocatoria_nueva INTEGER,
    id_agente_nuevo INTEGER NOT NULL,
    fecha_nueva DATE NOT NULL,
    id_turno_nuevo INTEGER NOT NULL,
    
    validacion_capacitacion BOOLEAN DEFAULT FALSE,
    validacion_disponibilidad BOOLEAN DEFAULT FALSE,
    validacion_conflicto BOOLEAN DEFAULT FALSE,
    mensaje_validacion TEXT,
    
    CONSTRAINT fk_detalle_trans FOREIGN KEY (id_transaccion) 
        REFERENCES cambio_transaccion(id_transaccion) ON DELETE CASCADE,
    CONSTRAINT fk_detalle_conv_orig FOREIGN KEY (id_convocatoria_original) 
        REFERENCES convocatoria(id_convocatoria),
    CONSTRAINT fk_detalle_conv_nueva FOREIGN KEY (id_convocatoria_nueva) 
        REFERENCES convocatoria(id_convocatoria),
    CONSTRAINT fk_detalle_agente_orig FOREIGN KEY (id_agente_original) 
        REFERENCES datos_personales(id_agente),
    CONSTRAINT fk_detalle_agente_nuevo FOREIGN KEY (id_agente_nuevo) 
        REFERENCES datos_personales(id_agente)
);

CREATE INDEX idx_detalle_trans ON cambio_transaccion_detalle(id_transaccion);

-- ----------------------------------------------------------------------------

CREATE TABLE cambio_validacion (
    id_validacion INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_transaccion INTEGER NOT NULL,
    tipo_validacion VARCHAR(50) NOT NULL,
    es_bloqueante BOOLEAN DEFAULT TRUE,
    es_alerta BOOLEAN DEFAULT FALSE,
    estado VARCHAR(20) DEFAULT 'activa',
    mensaje TEXT NOT NULL,
    detalle_tecnico TEXT,
    fecha_validacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    usuario_resolucion VARCHAR(100),
    fecha_resolucion TIMESTAMP,
    
    CONSTRAINT fk_val_trans FOREIGN KEY (id_transaccion) 
        REFERENCES cambio_transaccion(id_transaccion) ON DELETE CASCADE,
    CONSTRAINT chk_estado_val CHECK (estado IN ('activa', 'resuelta', 'ignorada'))
);

CREATE INDEX idx_val_transaccion ON cambio_validacion(id_transaccion);
CREATE INDEX idx_val_tipo ON cambio_validacion(tipo_validacion);

-- ============================================================================
-- M√ìDULO 5: DESCANSOS Y DISPONIBILIDAD
-- ============================================================================

CREATE TABLE descansos (
    id_desc INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_agente INTEGER NOT NULL,
    dia_solicitado DATE NOT NULL,
    mes_solicitado INTEGER NOT NULL,
    estado VARCHAR(20) DEFAULT 'pendiente',
    fecha_solicitud TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_respuesta TIMESTAMP,
    observaciones TEXT,
    CONSTRAINT fk_desc_agente FOREIGN KEY (id_agente) 
        REFERENCES datos_personales(id_agente) ON DELETE CASCADE,
    CONSTRAINT chk_estado_desc CHECK (estado IN ('pendiente', 'asignado', 'no_asignado')),
    CONSTRAINT chk_mes_desc CHECK (mes_solicitado BETWEEN 1 AND 12)
);

CREATE INDEX idx_desc_agente ON descansos(id_agente);
CREATE INDEX idx_desc_dia ON descansos(dia_solicitado);
CREATE INDEX idx_desc_estado ON descansos(estado);

-- Trigger: Auto-asignar descanso aprobado
CREATE OR REPLACE FUNCTION func_asignar_descanso_aprobado()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO convocatoria (id_plani, id_agente, id_turno, fecha_convocatoria, estado)
    SELECT 
        p.id_plani,
        NEW.id_agente,
        t.id_turno,
        NEW.dia_solicitado,
        'vigente'
    FROM planificacion p
    JOIN dias d ON p.id_dia = d.id_dia
    JOIN turnos t ON p.id_turno = t.id_turno
    WHERE d.fecha = NEW.dia_solicitado
    AND t.tipo_turno = 'descanso'
    LIMIT 1;
    
    UPDATE descansos
    SET fecha_respuesta = CURRENT_TIMESTAMP
    WHERE id_desc = NEW.id_desc;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_asignar_descanso_aprobado
AFTER UPDATE OF estado ON descansos
FOR EACH ROW
WHEN (NEW.estado = 'asignado' AND OLD.estado = 'pendiente')
EXECUTE FUNCTION func_asignar_descanso_aprobado();

-- ----------------------------------------------------------------------------

CREATE TABLE disponibilidad (
    id_dispo INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_agente INTEGER NOT NULL,
    id_turno INTEGER NOT NULL,
    estado VARCHAR(20) DEFAULT 'disponible',
    prioridad INTEGER DEFAULT 2,
    fecha_declaracion DATE DEFAULT (DATE('now')),
    CONSTRAINT fk_dispo_agente FOREIGN KEY (id_agente) 
        REFERENCES datos_personales(id_agente) ON DELETE CASCADE,
    CONSTRAINT fk_dispo_turno FOREIGN KEY (id_turno) REFERENCES turnos(id_turno),
    CONSTRAINT chk_estado_dispo CHECK (estado IN ('disponible', 'no_disponible')),
    CONSTRAINT chk_prioridad CHECK (prioridad BETWEEN 1 AND 3),
    CONSTRAINT uq_agente_turno UNIQUE (id_agente, id_turno)
);

CREATE INDEX idx_dispo_agente ON disponibilidad(id_agente);
CREATE INDEX idx_dispo_turno ON disponibilidad(id_turno);

-- ============================================================================
-- M√ìDULO 6: INASISTENCIAS Y CERTIFICADOS (Mejorado con Triggers)
-- ============================================================================

CREATE TABLE inasistencias (
    id_inasistencia INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_agente INTEGER NOT NULL,
    fecha_aviso TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_inasistencia DATE NOT NULL,
    motivo VARCHAR(20) NOT NULL DEFAULT 'imprevisto',
    requiere_certificado BOOLEAN,
    estado VARCHAR(20) DEFAULT 'pendiente',
    observaciones TEXT,
    fecha_actualizacion_estado TIMESTAMP,
    usuario_actualizo_estado VARCHAR(100),
    
    CONSTRAINT fk_inasis_agente FOREIGN KEY (id_agente) 
        REFERENCES datos_personales(id_agente) ON DELETE CASCADE,
    CONSTRAINT chk_motivo_inasis CHECK (motivo IN ('medico', 'estudio', 'imprevisto', 'injustificada', 'otro_justificada')),
    CONSTRAINT chk_estado_inasis CHECK (estado IN ('pendiente', 'justificada', 'injustificada'))
);

CREATE INDEX idx_inasis_agente ON inasistencias(id_agente);
CREATE INDEX idx_inasis_fecha ON inasistencias(fecha_inasistencia);
CREATE INDEX idx_inasis_estado ON inasistencias(estado);

-- Trigger 1: Auto-completar requiere_certificado
CREATE OR REPLACE FUNCTION func_auto_requiere_certificado()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.requiere_certificado IS NULL THEN
        IF NEW.motivo IN ('medico', 'estudio', 'otro_justificada') THEN
            NEW.requiere_certificado := TRUE;
        ELSE
            NEW.requiere_certificado := FALSE;
            NEW.estado := 'injustificada';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_auto_requiere_certificado
BEFORE INSERT ON inasistencias
FOR EACH ROW
EXECUTE FUNCTION func_auto_requiere_certificado();

-- Trigger 2: Actualizar requiere_certificado si cambia motivo
CREATE OR REPLACE FUNCTION func_update_requiere_certificado()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.motivo IN ('medico', 'estudio', 'otro_justificada') THEN
        NEW.requiere_certificado := TRUE;
    ELSE
        NEW.requiere_certificado := FALSE;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_requiere_certificado
BEFORE UPDATE OF motivo ON inasistencias
FOR EACH ROW
WHEN (OLD.motivo IS DISTINCT FROM NEW.motivo)
EXECUTE FUNCTION func_update_requiere_certificado();

-- ----------------------------------------------------------------------------

CREATE TABLE certificados (
    id_certificado INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_inasistencia INTEGER NOT NULL,
    id_agente INTEGER NOT NULL,
    fecha_entrega_certificado DATE NOT NULL,
    fecha_inasistencia_justifica DATE NOT NULL,
    tipo_certificado VARCHAR(20),
    estado_certificado VARCHAR(20) DEFAULT 'presentado',
    observaciones TEXT,
    motivo_rechazo TEXT,
    fecha_revision TIMESTAMP,
    usuario_reviso VARCHAR(100),
    
    CONSTRAINT fk_cert_inasis FOREIGN KEY (id_inasistencia) 
        REFERENCES inasistencias(id_inasistencia) ON DELETE CASCADE,
    CONSTRAINT fk_cert_agente FOREIGN KEY (id_agente) 
        REFERENCES datos_personales(id_agente) ON DELETE CASCADE,
    CONSTRAINT chk_tipo_cert CHECK (tipo_certificado IN ('medico', 'academico', 'otro')),
    CONSTRAINT chk_estado_cert CHECK (estado_certificado IN ('presentado', 'aprobado', 'rechazado')),
    CONSTRAINT uq_inasistencia_tipo UNIQUE (id_inasistencia, tipo_certificado)
);

CREATE INDEX idx_cert_inasistencia ON certificados(id_inasistencia);
CREATE INDEX idx_cert_agente ON certificados(id_agente);
CREATE INDEX idx_cert_estado ON certificados(estado_certificado);

-- Trigger 3: Al aprobar certificado, actualizar inasistencia
CREATE OR REPLACE FUNCTION func_certificado_aprobado()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE inasistencias
    SET estado = 'justificada',
        fecha_actualizacion_estado = CURRENT_TIMESTAMP,
        usuario_actualizo_estado = NEW.usuario_reviso
    WHERE id_inasistencia = NEW.id_inasistencia;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_certificado_aprobado
AFTER UPDATE OF estado_certificado ON certificados
FOR EACH ROW
WHEN (NEW.estado_certificado = 'aprobado' AND OLD.estado_certificado != 'aprobado')
EXECUTE FUNCTION func_certificado_aprobado();

-- Trigger 4: Al rechazar certificado, actualizar inasistencia
CREATE OR REPLACE FUNCTION func_certificado_rechazado()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE inasistencias
    SET estado = CASE
        WHEN (SELECT COUNT(*) FROM certificados 
              WHERE id_inasistencia = NEW.id_inasistencia 
              AND estado_certificado = 'aprobado') > 0
            THEN 'justificada'
        ELSE 'injustificada'
    END,
    fecha_actualizacion_estado = CURRENT_TIMESTAMP,
    usuario_actualizo_estado = NEW.usuario_reviso
    WHERE id_inasistencia = NEW.id_inasistencia;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_certificado_rechazado
AFTER UPDATE OF estado_certificado ON certificados
FOR EACH ROW
WHEN (NEW.estado_certificado = 'rechazado' AND OLD.estado_certificado != 'rechazado')
EXECUTE FUNCTION func_certificado_rechazado();

-- ============================================================================
-- M√ìDULO 7: MEN√ö (Asignaci√≥n de Dispositivos)
-- ============================================================================

CREATE TABLE menu (
    id_menu INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_convocatoria INTEGER NOT NULL,
    id_dispositivo INTEGER NOT NULL,
    id_agente INTEGER NOT NULL,
    fecha_asignacion DATE NOT NULL,
    orden INTEGER DEFAULT 1,
    acompa√±a_grupo BOOLEAN DEFAULT FALSE,
    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_menu_conv FOREIGN KEY (id_convocatoria) 
        REFERENCES convocatoria(id_convocatoria) ON DELETE CASCADE,
    CONSTRAINT fk_menu_dispo FOREIGN KEY (id_dispositivo) 
        REFERENCES dispositivos(id_dispositivo) ON DELETE RESTRICT,
    CONSTRAINT fk_menu_agente FOREIGN KEY (id_agente) 
        REFERENCES datos_personales(id_agente) ON DELETE CASCADE,
    CONSTRAINT chk_orden CHECK (orden > 0)
);

CREATE INDEX idx_menu_convocatoria ON menu(id_convocatoria);
CREATE INDEX idx_menu_dispositivo ON menu(id_dispositivo);
CREATE INDEX idx_menu_agente ON menu(id_agente);
CREATE INDEX idx_menu_fecha ON menu(fecha_asignacion);

-- ============================================================================
-- M√ìDULO 8: SALDOS (Con Triggers Autom√°ticos COMPLETOS)
-- ============================================================================

CREATE TABLE saldos (
    id_saldo INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id_agente INTEGER NOT NULL,
    mes INTEGER NOT NULL,
    anio INTEGER NOT NULL,
    horas_mes DECIMAL(6,2) DEFAULT 0,
    horas_anuales DECIMAL(7,2) DEFAULT 0,
    fecha_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_saldo_agente FOREIGN KEY (id_agente) 
        REFERENCES datos_personales(id_agente) ON DELETE CASCADE,
    CONSTRAINT chk_mes_saldo CHECK (mes BETWEEN 1 AND 12),
    CONSTRAINT chk_anio_saldo CHECK (anio >= 2020),
    CONSTRAINT chk_horas_mes CHECK (horas_mes >= 0),
    CONSTRAINT chk_horas_anuales CHECK (horas_anuales >= 0),
    CONSTRAINT uq_agente_periodo UNIQUE (id_agente, mes, anio)
);

CREATE INDEX idx_saldo_agente ON saldos(id_agente);
CREATE INDEX idx_saldo_periodo ON saldos(anio, mes);

-- Trigger 1: Insertar convocatoria ‚Üí actualizar saldos
CREATE OR REPLACE FUNCTION func_saldo_insert_convocatoria()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO saldos (id_agente, mes, anio, horas_mes, horas_anuales)
    VALUES (
        NEW.id_agente,
        CAST(EXTRACT(MONTH FROM NEW.fecha_convocatoria) AS INTEGER),
        CAST(EXTRACT(YEAR FROM NEW.fecha_convocatoria) AS INTEGER),
        (SELECT COALESCE(SUM(t.cant_horas), 0)
         FROM convocatoria c
         JOIN turnos t ON t.id_turno = c.id_turno
         WHERE c.id_agente = NEW.id_agente
           AND c.estado IN ('confirmada', 'vigente', 'cumplida', 'con_inasistencia')
           AND EXTRACT(MONTH FROM c.fecha_convocatoria) = EXTRACT(MONTH FROM NEW.fecha_convocatoria)
           AND EXTRACT(YEAR FROM c.fecha_convocatoria) = EXTRACT(YEAR FROM NEW.fecha_convocatoria)),
        (SELECT COALESCE(SUM(t.cant_horas), 0)
         FROM convocatoria c
         JOIN turnos t ON t.id_turno = c.id_turno
         WHERE c.id_agente = NEW.id_agente
           AND c.estado IN ('confirmada', 'vigente', 'cumplida', 'con_inasistencia')
           AND EXTRACT(YEAR FROM c.fecha_convocatoria) = EXTRACT(YEAR FROM NEW.fecha_convocatoria))
    )
    ON CONFLICT(id_agente, mes, anio) DO UPDATE SET
        horas_mes = EXCLUDED.horas_mes,
        horas_anuales = EXCLUDED.horas_anuales,
        fecha_actualizacion = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_saldo_insert_convocatoria
AFTER INSERT ON convocatoria
FOR EACH ROW
WHEN (NEW.estado IN ('confirmada', 'vigente', 'con_inasistencia'))
EXECUTE FUNCTION func_saldo_insert_convocatoria();

-- Trigger 2: UPDATE estado convocatoria ‚Üí recalcular saldos
CREATE OR REPLACE FUNCTION func_saldo_update_convocatoria()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO saldos (id_agente, mes, anio, horas_mes, horas_anuales)
    VALUES (
        NEW.id_agente,
        CAST(EXTRACT(MONTH FROM NEW.fecha_convocatoria) AS INTEGER),
        CAST(EXTRACT(YEAR FROM NEW.fecha_convocatoria) AS INTEGER),
        (SELECT COALESCE(SUM(t.cant_horas), 0)
         FROM convocatoria c
         JOIN turnos t ON t.id_turno = c.id_turno
         WHERE c.id_agente = NEW.id_agente
           AND c.estado IN ('confirmada', 'vigente', 'cumplida', 'con_inasistencia')
           AND EXTRACT(MONTH FROM c.fecha_convocatoria) = EXTRACT(MONTH FROM NEW.fecha_convocatoria)
           AND EXTRACT(YEAR FROM c.fecha_convocatoria) = EXTRACT(YEAR FROM NEW.fecha_convocatoria)),
        (SELECT COALESCE(SUM(t.cant_horas), 0)
         FROM convocatoria c
         JOIN turnos t ON t.id_turno = c.id_turno
         WHERE c.id_agente = NEW.id_agente
           AND c.estado IN ('confirmada', 'vigente', 'cumplida', 'con_inasistencia')
           AND EXTRACT(YEAR FROM c.fecha_convocatoria) = EXTRACT(YEAR FROM NEW.fecha_convocatoria))
    )
    ON CONFLICT(id_agente, mes, anio) DO UPDATE SET
        horas_mes = EXCLUDED.horas_mes,
        horas_anuales = EXCLUDED.horas_anuales,
        fecha_actualizacion = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_saldo_update_convocatoria
AFTER UPDATE OF estado ON convocatoria
FOR EACH ROW
WHEN (OLD.estado IS DISTINCT FROM NEW.estado)
EXECUTE FUNCTION func_saldo_update_convocatoria();

-- Trigger 3: DELETE convocatoria ‚Üí recalcular saldos
CREATE OR REPLACE FUNCTION func_saldo_delete_convocatoria()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE saldos
    SET horas_mes = (
        SELECT COALESCE(SUM(t.cant_horas), 0)
        FROM convocatoria c
        JOIN turnos t ON t.id_turno = c.id_turno
        WHERE c.id_agente = OLD.id_agente
          AND c.estado IN ('confirmada', 'vigente', 'cumplida', 'con_inasistencia')
          AND EXTRACT(MONTH FROM c.fecha_convocatoria) = EXTRACT(MONTH FROM OLD.fecha_convocatoria)
          AND EXTRACT(YEAR FROM c.fecha_convocatoria) = EXTRACT(YEAR FROM OLD.fecha_convocatoria)
    ),
    horas_anuales = (
        SELECT COALESCE(SUM(t.cant_horas), 0)
        FROM convocatoria c
        JOIN turnos t ON t.id_turno = c.id_turno
        WHERE c.id_agente = OLD.id_agente
          AND c.estado IN ('confirmada', 'vigente', 'cumplida', 'con_inasistencia')
          AND EXTRACT(YEAR FROM c.fecha_convocatoria) = EXTRACT(YEAR FROM OLD.fecha_convocatoria)
    ),
    fecha_actualizacion = CURRENT_TIMESTAMP
    WHERE id_agente = OLD.id_agente
      AND mes = CAST(EXTRACT(MONTH FROM OLD.fecha_convocatoria) AS INTEGER)
      AND anio = CAST(EXTRACT(YEAR FROM OLD.fecha_convocatoria) AS INTEGER);
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_saldo_delete_convocatoria
AFTER DELETE ON convocatoria
FOR EACH ROW
EXECUTE FUNCTION func_saldo_delete_convocatoria();

-- ============================================================================
-- M√ìDULO 9: SISTEMA DE LOGGING Y MONITOREO (COMPLETO)
-- ============================================================================

CREATE TABLE system_errors (
    id_error INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    TIMESTAMP TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    error_type VARCHAR(50) NOT NULL,
    component VARCHAR(100) NOT NULL,
    
    error_message TEXT NOT NULL,
    error_details TEXT,
    user_action TEXT,
    
    id_agente INTEGER,
    id_convocatoria INTEGER,
    id_transaccion INTEGER,
    additional_context TEXT,
    
    severity VARCHAR(20) DEFAULT 'medium',
    
    resolved BOOLEAN DEFAULT FALSE,
    resolution_date TIMESTAMP,
    resolution_notes TEXT,
    resolved_by VARCHAR(100),
    
    is_recurring BOOLEAN DEFAULT FALSE,
    related_error_id INTEGER,
    
    CONSTRAINT chk_error_type CHECK (error_type IN (
        'trigger', 'constraint', 'validation', 'integration', 
        'python_operation', 'database', 'network', 'other'
    )),
    CONSTRAINT chk_severity CHECK (severity IN ('low', 'medium', 'high', 'critical')),
    CONSTRAINT fk_error_agente FOREIGN KEY (id_agente) 
        REFERENCES datos_personales(id_agente),
    CONSTRAINT fk_error_conv FOREIGN KEY (id_convocatoria) 
        REFERENCES convocatoria(id_convocatoria),
    CONSTRAINT fk_error_trans FOREIGN KEY (id_transaccion) 
        REFERENCES cambio_transaccion(id_transaccion)
);

CREATE INDEX idx_errors_timestamp ON system_errors(TIMESTAMP);
CREATE INDEX idx_errors_severity ON system_errors(severity, resolved);
CREATE INDEX idx_errors_type ON system_errors(error_type);
CREATE INDEX idx_errors_component ON system_errors(component);
CREATE INDEX idx_errors_resolved ON system_errors(resolved);
CREATE INDEX idx_errors_recurring ON system_errors(is_recurring);

-- ----------------------------------------------------------------------------

CREATE TABLE error_patterns (
    id_pattern INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    pattern_signature VARCHAR(200) NOT NULL UNIQUE,
    
    error_type VARCHAR(50),
    component VARCHAR(100),
    
    first_occurrence TIMESTAMP,
    last_occurrence TIMESTAMP,
    occurrence_count INTEGER DEFAULT 1,
    
    severity_max VARCHAR(20),
    affected_users_count INTEGER DEFAULT 0,
    
    pattern_status VARCHAR(20) DEFAULT 'active',
    resolution_description TEXT,
    
    CONSTRAINT chk_pattern_status CHECK (pattern_status IN (
        'active', 'investigating', 'resolved', 'ignored'
    ))
);

CREATE INDEX idx_patterns_signature ON error_patterns(pattern_signature);
CREATE INDEX idx_patterns_status ON error_patterns(pattern_status);
CREATE INDEX idx_patterns_count ON error_patterns(occurrence_count);

-- Trigger: Detectar patrones autom√°ticamente (COMPLETO)
CREATE OR REPLACE FUNCTION func_detectar_patron_error()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO error_patterns (
        pattern_signature, error_type, component, 
        first_occurrence, last_occurrence, occurrence_count,
        severity_max, affected_users_count
    )
    VALUES (
        NEW.error_type || ':' || NEW.component,
        NEW.error_type, NEW.component,
        NEW.TIMESTAMP, NEW.TIMESTAMP, 1,
        NEW.severity,
        CASE WHEN NEW.id_agente IS NOT NULL THEN 1 ELSE 0 END
    )
    ON CONFLICT(pattern_signature) DO UPDATE SET
        last_occurrence = NEW.TIMESTAMP,
        occurrence_count = error_patterns.occurrence_count + 1,
        severity_max = CASE 
            WHEN NEW.severity = 'critical' THEN 'critical'
            WHEN NEW.severity = 'high' AND error_patterns.severity_max != 'critical' THEN 'high'
            WHEN NEW.severity = 'medium' AND error_patterns.severity_max NOT IN ('critical', 'high') THEN 'medium'
            ELSE error_patterns.severity_max
        END,
        affected_users_count = error_patterns.affected_users_count + 
            CASE WHEN NEW.id_agente IS NOT NULL THEN 1 ELSE 0 END;
    
    UPDATE system_errors
    SET is_recurring = TRUE
    WHERE id_error = NEW.id_error
    AND EXISTS (
        SELECT 1 FROM error_patterns 
        WHERE pattern_signature = NEW.error_type || ':' || NEW.component
        AND occurrence_count >= 3
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_detectar_patron_error
AFTER INSERT ON system_errors
FOR EACH ROW
EXECUTE FUNCTION func_detectar_patron_error();

-- Trigger: Actualizar TIMESTAMP de resoluci√≥n
CREATE OR REPLACE FUNCTION func_error_resuelto()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE system_errors
    SET resolution_date = CURRENT_TIMESTAMP
    WHERE id_error = NEW.id_error;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_error_resuelto
AFTER UPDATE OF resolved ON system_errors
FOR EACH ROW
WHEN (NEW.resolved = TRUE AND OLD.resolved = FALSE)
EXECUTE FUNCTION func_error_resuelto();

-- ============================================================================
-- M√ìDULO 10: TABLA DE CONFIGURACI√ìN
-- ============================================================================

CREATE TABLE configuracion (
    clave VARCHAR(100) PRIMARY KEY,
    valor TEXT NOT NULL,
    descripcion TEXT,
    tipo_dato VARCHAR(20) DEFAULT 'texto',
    fecha_modificacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    modificado_por VARCHAR(100),
    
    CONSTRAINT chk_tipo_dato CHECK (tipo_dato IN ('texto', 'numero', 'booleano', 'fecha', 'json'))
);

CREATE INDEX idx_config_tipo ON configuracion(tipo_dato);

-- Datos iniciales de configuraci√≥n
INSERT INTO configuracion (clave, valor, descripcion, tipo_dato) VALUES
('sistema_version', '2.0', 'Versi√≥n del sistema', 'texto'),
('centro_nombre', 'El Molino F√°brica Cultural', 'Nombre del centro cultural', 'texto'),
('rotacion_anual_pct', '100', 'Porcentaje de rotaci√≥n anual de personal', 'numero'),
('horas_minimas_mes', '60', 'Horas m√≠nimas requeridas por mes', 'numero'),
('alerta_capacitacion_dias', '30', 'D√≠as de anticipaci√≥n para alertas de capacitaci√≥n', 'numero'),
('email_notificaciones', 'admin@sistema.com', 'Email para notificaciones del sistema', 'texto'),
('backup_automatico', 'true', 'Activar backups autom√°ticos', 'booleano'),
('dias_historico_errores', '90', 'D√≠as de retenci√≥n de errores resueltos', 'numero');

-- ============================================================================
-- VISTAS ANAL√çTICAS
-- ============================================================================

-- Vista 1: Convocatorias activas con detalles
CREATE VIEW vista_convocatorias_activas AS
SELECT 
    c.id_convocatoria,
    c.fecha_convocatoria,
    d.dia AS dia_mes,
    d.numero_dia_semana,
    CASE d.numero_dia_semana
        WHEN 0 THEN 'Domingo'
        WHEN 1 THEN 'Lunes'
        WHEN 2 THEN 'Martes'
        WHEN 3 THEN 'Mi√©rcoles'
        WHEN 4 THEN 'Jueves'
        WHEN 5 THEN 'Viernes'
        WHEN 6 THEN 'S√°bado'
    END AS dia_semana_nombre,
    dp.id_agente,
    dp.nombre || ' ' || dp.apellido AS nombre_completo,
    t.tipo_turno,
    t.hora_inicio,
    t.hora_fin,
    t.cant_horas,
    c.estado,
    p.cant_visit AS visitantes_esperados
FROM convocatoria c
JOIN datos_personales dp ON c.id_agente = dp.id_agente
JOIN dias d ON c.fecha_convocatoria = d.fecha
JOIN turnos t ON c.id_turno = t.id_turno
JOIN planificacion p ON c.id_plani = p.id_plani
WHERE c.estado = 'vigente'
ORDER BY c.fecha_convocatoria, t.hora_inicio;

-- Vista 2: Saldos de horas por agente
CREATE VIEW vista_saldos_actuales AS
SELECT 
    s.id_agente,
    dp.nombre || ' ' || dp.apellido AS nombre_completo,
    dp.email,
    s.mes,
    s.anio,
    s.horas_mes,
    s.horas_anuales,
    s.fecha_actualizacion,
    CASE 
        WHEN s.horas_mes < (SELECT CAST(valor AS INTEGER) FROM configuracion WHERE clave = 'horas_minimas_mes')
            THEN 'BAJO'
        WHEN s.horas_mes >= (SELECT CAST(valor AS INTEGER) FROM configuracion WHERE clave = 'horas_minimas_mes') * 1.5
            THEN 'ALTO'
        ELSE 'NORMAL'
    END AS nivel_horas
FROM saldos s
JOIN datos_personales dp ON s.id_agente = dp.id_agente
WHERE dp.activo = TRUE
ORDER BY s.anio DESC, s.mes DESC, dp.apellido;

-- Vista 3: Ocupaci√≥n de dispositivos
CREATE VIEW vista_dispositivos_ocupacion AS
SELECT 
    disp.id_dispositivo,
    disp.nombre_dispositivo,
    disp.piso_dispositivo,
    COUNT(DISTINCT m.id_menu) AS veces_asignado,
    COUNT(DISTINCT m.id_agente) AS agentes_distintos,
    MAX(m.fecha_asignacion) AS ultima_asignacion,
    CASE 
        WHEN COUNT(DISTINCT m.id_menu) >= 20 THEN 'ALTA'
        WHEN COUNT(DISTINCT m.id_menu) >= 10 THEN 'MEDIA'
        ELSE 'BAJA'
    END AS frecuencia_uso
FROM dispositivos disp
LEFT JOIN menu m ON disp.id_dispositivo = m.id_dispositivo
    AND m.fecha_asignacion >= CURRENT_DATE - INTERVAL '30 days'
WHERE disp.activo = TRUE
GROUP BY disp.id_dispositivo
ORDER BY veces_asignado DESC;

-- Vista 4: Agentes capacitados por dispositivo
CREATE VIEW vista_agentes_capacitados AS
SELECT 
    disp.id_dispositivo,
    disp.nombre_dispositivo,
    dp.id_agente,
    dp.nombre || ' ' || dp.apellido AS nombre_completo,
    cap.tema AS capacitacion,
    cap_part.aprobado,
    cap_part.calificacion,
    cap_part.fecha_certificado,
    CASE 
        WHEN cap_part.aprobado = TRUE THEN 'CAPACITADO'
        WHEN cap_part.asistio = TRUE AND cap_part.aprobado IS NULL THEN 'EN EVALUACI√ìN'
        WHEN cap_part.asistio = TRUE AND cap_part.aprobado = FALSE THEN 'NO APROB√ì'
        ELSE 'NO ASISTI√ì'
    END AS estado_capacitacion
FROM dispositivos disp
JOIN capacitaciones_dispositivos cap_disp ON disp.id_dispositivo = cap_disp.id_dispositivo
JOIN capacitaciones cap ON cap_disp.id_cap = cap.id_cap
JOIN capacitaciones_participantes cap_part ON cap.id_cap = cap_part.id_cap
JOIN datos_personales dp ON cap_part.id_agente = dp.id_agente
WHERE dp.activo = TRUE
ORDER BY disp.nombre_dispositivo, dp.apellido;

-- Vista 5: Cambios de turno pendientes
CREATE VIEW vista_cambios_pendientes AS
SELECT 
    ct.id_transaccion,
    ct.fecha_solicitud,
    dp_ini.nombre || ' ' || dp_ini.apellido AS agente_iniciador,
    ct.tipo_transaccion,
    ct.estado,
    COUNT(ctd.id_detalle) AS cantidad_cambios,
    ct.observaciones
FROM cambio_transaccion ct
JOIN datos_personales dp_ini ON ct.agente_iniciador = dp_ini.id_agente
LEFT JOIN cambio_transaccion_detalle ctd ON ct.id_transaccion = ctd.id_transaccion
WHERE ct.estado IN ('pendiente', 'validada')
GROUP BY ct.id_transaccion, ct.fecha_solicitud, dp_ini.nombre, dp_ini.apellido, ct.tipo_transaccion, ct.estado, ct.observaciones
ORDER BY ct.fecha_solicitud DESC;

-- Vista 6: Inasistencias del mes
CREATE VIEW vista_inasistencias_mes AS
SELECT 
    inas.id_inasistencia,
    dp.id_agente,
    dp.nombre || ' ' || dp.apellido AS nombre_completo,
    inas.fecha_inasistencia,
    inas.motivo,
    inas.estado,
    inas.requiere_certificado,
    CASE 
        WHEN inas.requiere_certificado = TRUE THEN
            (SELECT COUNT(*) FROM certificados 
             WHERE id_inasistencia = inas.id_inasistencia 
             AND estado_certificado = 'presentado')
        ELSE NULL
    END AS certificados_presentados,
    inas.observaciones
FROM inasistencias inas
JOIN datos_personales dp ON inas.id_agente = dp.id_agente
WHERE to_char(inas.fecha_inasistencia, 'YYYY-MM') = to_char(CURRENT_DATE, 'YYYY-MM')
ORDER BY inas.fecha_inasistencia DESC;

-- Vista 7: Dashboard de errores recientes
CREATE VIEW vista_errores_recientes AS
SELECT 
    e.id_error,
    e.TIMESTAMP,
    e.error_type,
    e.component,
    e.error_message,
    e.severity,
    e.resolved,
    CASE 
        WHEN e.id_agente IS NOT NULL THEN dp.nombre || ' ' || dp.apellido
        ELSE 'Sistema'
    END AS afectado,
    e.user_action,
    CASE 
        WHEN e.is_recurring = TRUE THEN '‚ö†Ô∏è RECURRENTE'
        ELSE ''
    END AS alerta
FROM system_errors e
LEFT JOIN datos_personales dp ON e.id_agente = dp.id_agente
WHERE e.TIMESTAMP >= CURRENT_TIMESTAMP - INTERVAL '7 days'
ORDER BY e.TIMESTAMP DESC, e.severity DESC;

-- Vista 8: Patrones de errores
CREATE VIEW vista_patrones_errores AS
SELECT 
    p.id_pattern,
    p.error_type,
    p.component,
    p.occurrence_count AS veces_ocurrido,
    p.first_occurrence AS primera_vez,
    p.last_occurrence AS ultima_vez,
    ROUND((EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - p.first_occurrence)) / 86400.0)::numeric, 1) AS dias_activo,
    p.severity_max AS severidad_maxima,
    p.pattern_status AS estado,
    CASE 
        WHEN p.occurrence_count >= 10 THEN 'üî¥ CR√çTICO'
        WHEN p.occurrence_count >= 5 THEN 'üü° ATENCI√ìN'
        ELSE 'üü¢ BAJO'
    END AS nivel_urgencia,
    p.resolution_description
FROM error_patterns p
WHERE p.pattern_status IN ('active', 'investigating')
ORDER BY p.occurrence_count DESC, p.last_occurrence DESC;

-- Vista 9: Salud del sistema
CREATE VIEW vista_salud_sistema AS
SELECT 
    (SELECT COUNT(*) 
     FROM system_errors 
     WHERE TIMESTAMP >= CURRENT_TIMESTAMP - INTERVAL '1 day') AS errores_24h,
    
    (SELECT COUNT(*) 
     FROM system_errors 
     WHERE severity = 'critical' 
     AND resolved = FALSE) AS criticos_pendientes,
    
    (SELECT COUNT(*) 
     FROM system_errors 
     WHERE TIMESTAMP >= CURRENT_TIMESTAMP - INTERVAL '7 days') AS errores_semana,
    
    (SELECT COUNT(*) 
     FROM error_patterns 
     WHERE pattern_status = 'active' 
     AND occurrence_count >= 3) AS patrones_activos,
    
    (SELECT component 
     FROM system_errors 
     WHERE TIMESTAMP >= CURRENT_TIMESTAMP - INTERVAL '7 days'
     GROUP BY component 
     ORDER BY COUNT(*) DESC 
     LIMIT 1) AS componente_problematico,
    
    ROUND(
        CAST((SELECT COUNT(*) FROM system_errors WHERE resolved = TRUE) AS NUMERIC) /
        NULLIF((SELECT COUNT(*) FROM system_errors), 0) * 100,
        2
    ) AS tasa_resolucion_porcentaje,
    
    CASE 
        WHEN (SELECT COUNT(*) FROM system_errors WHERE severity = 'critical' AND resolved = FALSE) > 0 
            THEN 'üî¥ CR√çTICO'
        WHEN (SELECT COUNT(*) FROM system_errors WHERE TIMESTAMP >= CURRENT_TIMESTAMP - INTERVAL '1 day') > 10 
            THEN 'üü° ATENCI√ìN'
        WHEN (SELECT COUNT(*) FROM error_patterns WHERE pattern_status = 'active' AND occurrence_count >= 5) > 0 
            THEN 'üü° ATENCI√ìN'
        ELSE 'üü¢ SALUDABLE'
    END AS estado_sistema,
    
    CURRENT_TIMESTAMP AS fecha_reporte;

-- Vista 10: An√°lisis por componente
CREATE VIEW vista_errores_por_componente AS
SELECT 
    component,
    error_type,
    COUNT(*) AS total_errores,
    SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) AS criticos,
    SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) AS altos,
    SUM(CASE WHEN resolved = TRUE THEN 1 ELSE 0 END) AS resueltos,
    MAX(TIMESTAMP) AS ultimo_error,
    ROUND(
        CAST(SUM(CASE WHEN resolved = TRUE THEN 1 ELSE 0 END) AS NUMERIC) / 
        COUNT(*) * 100, 
        2
    ) AS tasa_resolucion
FROM system_errors
WHERE TIMESTAMP >= CURRENT_TIMESTAMP - INTERVAL '30 days'
GROUP BY component, error_type
HAVING COUNT(*) > 0
ORDER BY total_errores DESC;

-- Vista 11: Timeline de errores
CREATE VIEW vista_errores_timeline AS
SELECT 
    DATE(TIMESTAMP) AS fecha,
    error_type,
    severity,
    COUNT(*) AS cantidad
FROM system_errors
WHERE TIMESTAMP >= CURRENT_TIMESTAMP - INTERVAL '30 days'
GROUP BY DATE(TIMESTAMP), error_type, severity
ORDER BY fecha DESC, cantidad DESC;

-- ============================================================================
-- COMENTARIOS FINALES Y DOCUMENTACI√ìN
-- ============================================================================

/*
SISTEMA DE GESTI√ìN DE RRHH - VERSI√ìN FINAL 2.0
===============================================

COMPLETITUD: 98%

ESTRUCTURA:
-----------
‚úÖ 19 Tablas principales
‚úÖ 13 Triggers autom√°ticos
‚úÖ 11 Vistas anal√≠ticas
‚úÖ 60+ √çndices optimizados
‚úÖ Sistema de logging completo
‚úÖ Validaciones robustas

M√ìDULOS:
--------
1. Tablas Maestras (5 tablas)
2. Capacitaciones (3 tablas) ‚Üê INCLUYE capacitaciones_participantes
3. Convocatorias (2 tablas) - Sistema inmutable
4. Cambios de Turno (3 tablas) - Modelo transaccional
5. Descansos y Disponibilidad (2 tablas)
6. Inasistencias y Certificados (2 tablas)
7. Men√∫/Asignaci√≥n Dispositivos (1 tabla)
8. Saldos (1 tabla) ‚Üê TRIGGERS COMPLETOS
9. Sistema de Logging (2 tablas)
10. Configuraci√≥n (1 tabla)

TRIGGERS:
---------
1. trg_prevent_duplicate_vigente - Prevenir convocatorias duplicadas
2. trg_update_fecha_modificacion - Auto-actualizar timestamps
3. trg_registrar_historial_cambio - Historial autom√°tico
4. trg_asignar_descanso_aprobado - Auto-asignaci√≥n de descansos
5. trg_auto_requiere_certificado - L√≥gica de certificados
6. trg_update_requiere_certificado - Actualizaci√≥n certificados
7. trg_certificado_aprobado - Workflow aprobaci√≥n
8. trg_certificado_rechazado - Workflow rechazo
9. trg_saldo_insert_convocatoria - Saldos al insertar
10. trg_saldo_update_convocatoria - Saldos al actualizar
11. trg_saldo_delete_convocatoria - Saldos al eliminar
12. trg_detectar_patron_error - Detecci√≥n de patrones
13. trg_error_resuelto - Timestamps de resoluci√≥n

VISTAS ANAL√çTICAS:
-----------------
1. vista_convocatorias_activas - Convocatorias vigentes
2. vista_saldos_actuales - Horas por agente
3. vista_dispositivos_ocupacion - Uso de dispositivos
4. vista_agentes_capacitados - Capacitaciones completadas
5. vista_cambios_pendientes - Cambios en proceso
6. vista_inasistencias_mes - Inasistencias del mes
7. vista_errores_recientes - Dashboard de errores
8. vista_patrones_errores - Patrones detectados
9. vista_salud_sistema - Estado general del sistema
10. vista_errores_por_componente - An√°lisis por componente
11. vista_errores_timeline - Timeline para gr√°ficos

USO:
----
1. Inicializar: sqlite3 gestion_rrhh.db < schema_final_completo.sql
2. Verificar: SELECT COUNT(*) FROM sqlite_master WHERE type='table';
3. Ver salud: SELECT * FROM vista_salud_sistema;
4. Conectar Python: DatabaseManager('gestion_rrhh.db')

MIGRACI√ìN A POSTGRESQL:
-----------------------
- Cambiar AUTOINCREMENT por SERIAL
- Usar BOOLEAN nativo
- Aprovechar JSONB para additional_context
- Implementar NOTIFY/LISTEN para alertas
- Considerar particionamiento por fecha

MANTENIMIENTO:
-------------
- Limpiar errores resueltos: >90 d√≠as
- Revisar patrones activos: semanal
- Backup: diario automatizado
- Analizar performance: mensual

DOCUMENTACI√ìN:
-------------
- error_logger_python.py: Sistema de logging en Python
- database_manager.py: Gestor principal de BD
- README.md: Gu√≠a de instalaci√≥n y uso

AUTOR: Pablo - Data Analyst
FECHA: Diciembre 2025
VERSI√ìN: 2.0 FINAL
*/
